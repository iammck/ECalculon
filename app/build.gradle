apply plugin: 'com.android.application'
apply plugin: 'com.github.triplet.play'

android {
    compileSdkVersion 22
    buildToolsVersion "21.1.2"

    defaultConfig {
        applicationId "com.mck.ecalculon"
        minSdkVersion 9
        targetSdkVersion 22
        versionCode 12
        versionName "basic"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }

    signingConfigs {
        travis {
            // if building with the ci service, this env var exists.
            if (System.getenv("KEY_ALIAS") != null){
                // specific to the ci build
                storeFile file("keystore/ecalculon.keystore")
                storePassword System.getenv("KSPWD")
                keyAlias System.getenv("KEY_ALIAS")
                keyPassword System.getenv("KEY_PWD")
            }
        }

        console {
            // we can find a console, is it also not the travis console?
            if (System.console() != null && System.getenv("KEY_ALIAS") == null){
                storeFile file("keystore/ecalculon.keystore")
                storePassword new String(System.console()
                        .readPassword("\n\$ Enter keystore password: "))
                keyAlias new String(System.console()
                        .readLine("\n\$ Enter key alias: "))
                keyPassword new String(System.console()
                        .readPassword("\n\$ Enter key password: "))
            }
        }

    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            // if building with the ci service
            if (System.getenv("KEY_ALIAS") != null){
                signingConfig signingConfigs.travis
            } else if ( System.console() != null){
                signingConfig signingConfigs.console
            }
        }
    }
    packagingOptions {
        exclude 'LICENSE.txt'
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.android.support:appcompat-v7:22.0.0'

    androidTestCompile 'com.android.support.test.espresso:espresso-core:2.0'
}

/*play {
    serviceAccountEmail = ''
    pk12File = file("keystore/ecalculonp12.p12")
}*/

play {
    serviceAccountEmail = System.getenv("SAEMAIL")
    pk12File = file("keystore/ecalculonp12.p12")
}


////////////////
// PUBLISHING///
////////////////

/*
    A publish item in the commit msg must take the form of a string map
    with the first item specifying the name of the variant and
    the second is the track for each variant to be published.

    The list should be wrapped with [PUBLISH to the left and a ]
    to the right.

    eg
    [PUBLISH 'release' : 'alpha', 'flavorRelease' : 'beta']

    // the starting one will be
    [PUBLISH 'release' : 'alpha']

    To publish, first run getCommitMessage, then publish
    .\gradlew publishCheck publish

    The publish task depends upon publishVariants task which
    depends upon getCommitMessage task having already run.
    publishVariants uses the msg to get variant names, then
    it configures the publish task to also be dependent upon
    the cooresponding publishVaraint from triple-t plugin.

    To determine what is published, the msg is added to ext
    variables using the getCommitMessage task, yet execution
    of getCommitMessage must happen before configure phase
    is over. I am going to determine if two tasks in the same
    gradle command share project.ext instances by issuing
    something like .\gradlew getCommitMessage publish

    I might need to actually get and store the msg in file or
    add it as an environment variable. If so I should parse
    it down to just the important part.
 */

task getCommitMessagePublishMap(type:Exec){
    System.out.println("getCommitMessagePublishMap is being configured.")
    commandLine 'git','log', '-1'
    standardOutput = new ByteArrayOutputStream()
    doLast {

        System.out.println("getCommitMessagePublishMap doLiast is called with standardOutput"
                + standardOutput.toString())

        String publishMap = standardOutput.toString()
        if ( publishMap.contains('[RELEASE')){
            def start = it.indexOf('[RELEASE' + 8)
            def stop = it.indexOf(']', start)
            publishMap = '[' + it.getAt(start..stop) + ']';
        } else {
            publishMap = "[]"
        }
        java.nio.file.Files.write(
            java.nio.file.Paths.get('app', 'build', 'tmp', 'publishMap.txt'),
            publishMap.getBytes())
    }
}

task publishVariants {
    afterEvaluate {
        System.out.println("publishVariants afterEvaluate.")

        java.nio.file.Path pathToPublishMap =
                java.nio.file.Paths.get('app', 'build', 'tmp', 'publishMap.txt')
        if (java.nio.file.Files.exists(pathToPublishMap)) {
            File publishMapFile = pathToPublishMap.toFile()
            String pms = publishMapFile.getText()

            System.out.println("publishVariants afterEvaluate string found pms " + pms)

            // evaluate the publish Map, then for each variant and track pair,
            evaluate(pms).each { key, value ->
                // set up the varaint name.
                String variant = key[0].toUpperCase() + key.toString().substring(1)
                // this may need to happen after eval so that task exists.
                def publishVariant = project.tasks.getByName("publish" + variant)
                publish.dependsOn publishVariant // set publish depends on
                //set the publish variant task play track to the track b4 execution.
                publishVariant.doFirst { play.track = value }
            }
    }
    }
}

task publish(dependsOn:publishVariants)
// if any publishRealeasees are going to happen this task depends on them.

